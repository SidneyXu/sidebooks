---
weight: 1
title: Feed流系统
---

# Feed流系统

## 业务概述

角色模型

- 创作者（Followee）：又可以称为被关注者、Up、博主等。创作者可以发表信息（推文、博客）。
- 关注者（Follower）：又可以称为粉丝。关注者可以同时关注多个创作者。一个用户可以既是创作者也是关注者。

主要功能

- 发布信息
- 关注/取关用户
- Feed流展示：在所有用户的主页上展示关注的所有创作者的最新信息。Feed流可以是单纯基于时间的Timeline流，也可以是基于权重的Rank流，还可以是两者的结合。

## 数据建模

表结构

- Feed表：信息ID、创建人ID、创建时间、信息内容、信息状态。
	+ 信息ID应该包含创建时间（时间戳+递增序号），这样可以省去额外的时间排序。
	+ 分区方案：
		* 信息ID：聚合时需要跨多区。
		* 用户ID：分布不均匀，可能存在热点问题。
  
缓存方案

- 用户关系缓存：key=当前用户ID，field=关注的创作者IDs，value=创作者信息详情。
- 最新信息缓存：为活跃用户缓存过去五天发布的推文，key=当前用户ID，value=信息IDs。
- 收件箱缓存：对于上线用户采用写扩散，可以加速信息的实现获取速度。

## 消息处理模式

- 拉模式（读扩散）：创作者在发布信息时入自己的发件箱，关注者展示Feed流时需要从所有关注的人那里获得新信息或进行聚合。因为存在聚合所以性能会受到影响。
- 推模式（写扩散）：创作者在发布信息时写入所有关注者的收件箱，而关注者从自己的收件箱中构建Feed流。由于一份消息需要推送并存储多份，所以需要使用队列进行削峰，避免同时推送量扩大。
- 混合模式：
	+ 按创作者的关注用户数进行区别处理，用户少则采用写扩散，用户多则采用读扩散。
	+ 按用户是否上线进行区别处理，在线用户采用写扩散，离线用户采用读扩散。

## 生成Timeline型的Feed流

业务需求

- 显示当前用户关注的所有创作者的最新信息，按时间线倒序排列。
- 用户可以将关注的人进行分组，每个分组都有单独的Timeline。
- 当一个创作者删除某条信息后，关注他的用户应该看不到这条信息。
- 当一个用户取消关注某个创作者后，该用户就应该看不到该创作者的所有信息。

拉模式

1. 创作者发布信息写入收件箱的同时写入最新信息缓存。
2. 从用户关系缓存中获取当前用户关注的所有创作者的ID。
3. 根据创作者ID在最新信息缓存中找出所有匹配信息ID。
4. 在应用层面对信息ID集合进行聚合。
4. 过滤掉已被删除的信息以及取关的创作者所创建的信息。

推模式

1. 创作者发布信息时写入消息队列，广播到关注者的收件箱。
2. 从收件箱中取出所有信息。
3. 过滤掉已被删除的信息以及取关的创作者所创建的信息。

基于上线状态的推拉集合模式

1. 创建者发布信息时写入收件箱、最新信息缓存、在线用户的收件箱缓存。
2. 先检查收件箱缓存，没有数据时再使用拉模式进行聚合。

## 未读信息数方案

- **offset**：每个用户存储最新已读消息的offset。适合只需记录最新未读消息的场景，如IM聊天等。
- **bitmap映射**：将用户ID映射到bitmap上，已读则该bit设为1。适合需要详细区分每条消息的已读状态的场景，如系统通知等。
- **差集对比**：适合只需显示未读信息数，且数据规模大的信息流场景。
  1. 在缓存中记录关注的所有创作者的信息数，key=用户ID，hashKey=关注的创作者ID，value=count。
  2. 生成Feed流时，记录用户当前关注的所有创作者的信息数。
  3. 未读信息数 = 用户当前关注的所有人的信息数 - 快照中的信息数。
  4. 用户点击未读消息后，将用户当前关注的信息数刷新到快照中。
  
