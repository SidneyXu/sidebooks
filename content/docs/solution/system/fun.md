---
weight: 3
title: 基础功能
---

# 基础功能

## 分布式锁

### 设计原则

- 互斥性：同一个时间只能有一个线程持有锁。
- 容错性：即使某一个持有锁的线程异常退出，其他线程仍可获得锁。
- 隔离性：线程只能释放自己的锁，不能释放其他线程的锁。

### 数据库唯一索引

表上建立唯一索引，加锁时插入数据，释放锁是删除数据。

```
# 加锁
insert into locks values('lock_method_name');
# 释放锁
delete from locks where method_name = 'lock_method_name';
```

实现简单，非常适合对锁的一致性要求很高，但并发度较低的场合。比如说用于防止批处理任务被重复执行。

### Redis单节点锁

通过Redis进行加锁，可以同时设置超时时间。

```
# Redis层面
set key value [ex <second>|px <mill>] nx
# Java Client层面
template.opsForValue().setIfAbsent(key, value, timeout, TimeUnit.SECONDS);
```

- 优点：实现简单、高效，大部分场合使用该方法即可。
- 缺点：由于Redis采用异步复制，可能因为脑裂出现多个客户端持有锁；此外FGC等原因也可能造成持锁线程未完成任务后就因为超时释放锁，此时也会出现多个客户端持有锁。为了避免原持锁线程释放了此时已不属于自己的锁，需要将value设为唯一值。
- 解决方案：设计超时时间时预添加一段缓冲时间，也就是说把超时时间设得更长一点。还可以在刚开始获取锁时先获得版本号，实际获得锁后执行修改前检查版本号。

### Redission单节点锁（Watchdog）

通过Watchdog机制定期延长加锁时间，可以有效防止FGC等原因造成业务未执行完毕就释放锁的问题。不过对于异步复制引起的脑裂问题仍然没有办法。

### Redlock集群加锁

尝试在所有Redis节点加锁，并统计一半以上节点的加锁完成时间是否在阀值内，没有超时则加锁成功。

由于依赖时间，时钟漂移可能会产生问题；另外加锁顺序也存在数据安全隐患。目前争议较大，少有实施案例。

### Zookeeper

基于临时节点创建，由于Zookeeper采用强一致性，Leader切换时不提供服务，所以不存在脑裂问题。但是由于只有Leader提供服务，高并发时会有性能问题。

## 分布式ID

### 设计原则

- 全局唯一
- 单调递增
- 无序（无法推断规模）
- 高可用、高并发、低延迟

{{< hint info >}}
考虑到数据量大到一定规模后都会进行归档。为了确保新生成的ID和归档中的ID也不一致，最简单的实现办法就是在ID中包含时间标识。
{{< /hint >}}

### 数据库自增主键

使用多台数据库分摊压力，每台起始值和步长=节点数。为了防止主从切换导致计数器丢失，需要将集群配置为半同步复制模式。

- 优点：实现简单，利用数据库特性可以有效避免页分裂。
- 缺点：依赖数据库性能，数据有序可被推测规模。

### 数据库+代理服务

在数据库中建立分布式主键表，字段包含max_id、step和biz_type。代理服务每次获取一批ID保存在内存中，同时修改数据库的max_id的值。应用通过代理服务的接口获取ID。代理服务可以通过双缓冲机制避免ID用完后加载新ID引起的性能突刺。

- 优点：ID趋势递增。代理服务有缓存，DB宕机后也能工作一段时间。
- 缺点：ID有序。实现较复杂。引入了中间服务，存在性能损耗。

### 数据库+预置数据

每天日切后生成一批随机ID保存在数据库的未使用ID表中。应用或代理服务通过双缓冲机制获取ID，同时将表中ID移动到已使用ID表中。由于数据量够大，哪怕已使用ID表中的数据最终未被使用，也不用进行回滚。

- 优点：随机生成，数据完全无法预测。长度短，如果像Base64算法一样每一位表示64位数据，则6位数字就足够表示数百亿数据。
- 缺点：实现复杂。由于数据完全无序，直接用作数据库主键会引起页分裂。

### Snowflake算法

64位 = 保留位(1位) + 时间序列(41位) + Worker_ID(10位) + 自增序号(12位）

当同一机器两次获取的时间戳一致时，序列号就递增；当序列号用完后，程序会自旋直到下一个时间戳到来。为了防止时间漂移生成重复ID，需要引入ZooKeeper等手段保存上次ID的生成时间，当发生时钟回拨时自旋不提供服务，等待服务器追上当前时间。在QPS不高的情况下，可以将时间序列改为以秒为基准，确保自增序号不会总是1，或者每次时间拨动时自增序号的起始值做一下随机。

- 优点：高效，可以不依赖第三方组件（忽略时钟回拨的情况下）。
- 缺点：强依赖时钟，会有时钟回拨问题。默认实现下时间序列从1970年开始最多记录69年。数据长度太长。QPS不高情况下自增序号可能一直为1，无法作为分区键。

优化方案：大部分情况下可以使用更紧凑的时间格式和机器ID。例如：20位 = yy（年的后2位） + mmddHHmmssSSS + IP第4位 + 4位序列号。

### MD5/Hash算法

为每个系统分配一个系统标识，一般3个英文字母即可。然后对（系统标识+数据）进行Hash算法，计算结果即为分布式ID。

- 优点：随机生成，数据完全无法预测。实现简单。全局唯一。
- 缺点：由于数据完全无序，直接用作数据库主键会引起页分裂。数据长度过长，MD5也有128位。同样的数据只会生成同样的ID。

在一些情况下可以用来实现幂等性，确保同样的数据不会重复执行。


