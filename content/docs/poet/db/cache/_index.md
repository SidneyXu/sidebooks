---
title: 缓存
weight: 5
---

# 缓存数据库

## 知识点

Redis性能问题

- 大key或者多个key删除
- AOF同步写回
- AOF重写引起AOF写回阻塞，井AOF日志配置到SSD。
- 加载大RDB，一般控制在2G到4G。
- 在节点上执行聚合操作。
- 操作系统swap，通常发生在内存不足时。当出现百MB以上swap则需要加内存或加节点。可以通过redis-cli info | grep process_id命令查询swap大小。
- 使用了内存大页，生产中建议关闭。如果采用了内存大页，那么，即使客户端请求只修改 100B 的数据，Redis 也需要拷贝 2MB 的大页。相反，如果是常规内存页机制，只用拷贝 4KB。
- 开启了碎片清理，内存碎片清理由主线程操作。调小active-defrag-cycle-max ，控制内存碎片整理所用CPU时间。
- 从库落后太多，大key写入引起复制风暴

## 最佳实践

- 通用
  - 通过CAT等统计缓存命中率
  - 优先写数据库删缓存。特定情况可以同时更新数据库和缓存，比如新用户注册，删缓存没有意义，而注册后的用户大概率需要用到注册信息。
  - 适用场合：
    - 读多写少，更新不频繁的热点数据。
    - 计算代价大的数据。
    - 不与具体用户绑定，千人一面的数据。如商品页、排行榜、公告栏等。
    - 对数据一致性要求不严格。
- Redis
  - 持久化
    - Master最好不要做任何持久化工作，比如RDB内存快照和AOF日志文件
    - 如果数据比较重要，则在某个Slave开启AOF备份数据，策略设置为每秒同步一次
    - 如果数据非常重要，则同时开启RDB和AOF。 在这种情况下， 当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
    - 数据不能丢，AOF+RDB。
    - 允许分钟丢失，RDB。
    - 只用AOF时优先everysec。
  - 集群
    - Master和Slave在同一个局域网内。
    - 哨兵至少3个，且所有哨兵配置一样。
    - 为了避免主从同步时，主库全量RDB的压力，主从复制不要使用图状结构，而是使用级联的单向链表结构方式分摊压力。例如：从1，从2同步自主库。从3，从4同步自从1。
  - List只当队列用。
  - 大量数据用scan范围操作。
  - 布隆过滤器是大key，建议放在单独的Redis实例中。
  - 使用expire_at设置具体的过期时间点。而expire为存活时间，在从库为收到主库同步过来的命令的时间加上存活时间，所以可能发生过期读。
  - 通过unlink异步删除大key。
  - 关闭Huge page，避免AOF重写时因为大页拷贝引起的阻塞。

Redis Server

```yml
# 缓冲
## replication buffer大小。断开连接时会被清空。
client-output-buffer-limit=256mb

# 集群
## 防止脑裂
### 主库能进行数据同步的最少从库数量
min-slaves-to-write=从库数/2+1
### 主从同步时，从库给主库发送 ACK 消息的最大延迟时间（以秒为单位）
min-slaves-max-lag=10到20s
### 哨兵判断的客观下线时间。适当调大该值，当哨兵与主库之间网络存在短时波动时，可以降低误判的概率。但是调大也意味着主从切换的时间会变长，对业务的影响时间越久。
down-after-milliseconds=10s

## Redis Cluster集群
### 节点心跳超时时间。如果分片节点采用一主一从模式，如果主从切换过慢超过节点心跳超时时间。分片集群就会认为该节点右异常，如果一半异常集群就会停止服务，所以应该调大一点。
cluster-node-timeout=10到20s
```

